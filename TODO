-*- indented-text -*-

TODO list for sawmill
*********************

Bugs are marked !, things that should be done soon are marked +,
and longer-term ideas are marked -


Outstanding bugs
================

  ! Without GMC you can press button1 on root window, and holding it
    move over frame, and that frame gets clicked and action bound to
    this frame is taken

    Move cursor very slowly over frame holding button1

  ! While moving or resizing, when you release button and move mouse
    out of frame very fast, frame remains in highlighted state

  ! latency when starting menu subprocesses can be annoying (pointer
    events are handled unintuitively)

  ! shaped frame parts overlapping shaped client windows lose

    does this need fixing..? similarly, shaped frame parts overlapping
    each other will overwrite the lower part's mask..

  ! It's not possible to compile sawmill-ui.jl without an X connection
    (it requires 'gtk, which then calls gtk_init (), ...)

  ! Move functions.c:Fgetpid () to librep

  ! install-sh script isn't found from subdirectories?

    [workaround: install GNU fileutils]

  ! ICCCM says we should not passive grab on the client windows, but on
    our frames instead

  ! transient windows decorated as the non-transient ones, but certain
    applications like XMMS (that should not show decoraions at all)
    shows them in the playlist window and the equalizer window

    [ 1/10: should be fixed ]

  ! Every once in a while (haven't figured out a pattern yet), the
    mouse cursor locks up, and won't move at all.  After I press a
    mouse button, it goes back to normal again.

    (this could be due to grabbing in SyncPointer mode, but
    XAllowEvents should always be called..?)

  ! rebuild-frame shouldn't change any parts whose appearance (i.e.
    geometry, contents) haven't changed (need to store more state)

  ! desk-guide misinterprets the window geometries when there's more
    than one workspace, with multiple viewports

    (it looks as though it expects only windows on the _current_
    workspace to be moved with the viewport; the old gnome pager gets
    this right, so I don't think it's my fault. But enlightenment works
    with desk-guide but not with the old pager..!?)

    also, when workspaces are added it sometimes doesn't notice that
    the contents of the current workspace changed (since it still has
    the same index, i.e. insert before the first and move to it)

  ! xv/java-apps get weird placement [apps being non-ICCCM compliant?]


General tasks
=============

  + do the virtual-workspace edge-flipping thing?

  + option to re-place windows when they move workspaces/viewports?

  + use panes to separate areas in bindings widget

  + Include readline patch <199909301857.MAA00629@arachne.eng.utah.edu>

    need to work out autoconf stuff..

  + when cycling windows, show all names (with mark against current),
    but don't focus each temporarily selected window? (options?)

  + allow workspaces to be named?

    this is done, set the workspace-names variable to a list of
    strings; but it's not yet customizable through the ui

  + remember last focused window on each workspace?

    perhaps generalize the x-cycle-order property to be ever-present,
    then use it for this as well?

  + features for the gnome/redhat guys:

    * code to read the gnome apps menu, then replace apps-menu
      [2/10: this is pretty much done]

    * remove restart/quit/[about?] from the root menu

    * launch capplet instead of standalone config tool
      [use customize-program and customize-group-opt to do this]

    * 2x2 workspaces [30/9: this has been done]

    there will be a new lisp module (`gnome-int'?) that has these
    things as options (enabled by default). It will also require
    'gnome.

  + add capplet desktop entries to share/gnome/apps/Settings as well as
    the control center tree

    then again.. there's a problem with this -- gnome menus are
    _static_, whereas sawmill's customization groups are _dynamic_

    i.e. the `customization' root sub-menu wouldn't match the menu in
    the gnome `settings' tree. this would be bad since the user may not
    discover the dynamic menu and thus miss many of the options..

  + Ability to execute commands (like select-workspace:X) while
    moving/resizing.

    Could solve this by specifying a keymap to the
    grab-pointer/grab-keyboard functions, then evaluate the other type
    of events as normal

    Would this introduce other problems..? What if the outer command
    has the server grabbed (e.g. rubber-banding in progress)

    Also, what protection is there against the user doing something
    "foolish"? (like switching desktops while resizing a window)

  + option to maximize with frame outside the root boundaries?

    but only put the border of the window outside, not the title

    this would be hard to achieve (i.e. parsing the frame def)

  + option to disable moving/resizing in maximized state

    Why? I think that the user should always be able to manipulate the
    window if they wish to do so

  + tooltips in frame parts describing their keymaps

    requires extending show-message to do multi-line (justification?)

  + in interactive placement, allow the window-pointer position to be
    configurable 

  + change edge snapping to use resistance instead of magnetism?

    perhaps allow mode to be set as an option; it would be nice to
    differentiate between screen edges and window edges

  + allow configuration of where move/resize display appears

    allow relative to window, or relative to root, for both x and y

  + option for maximizing not to cover panels

  + Allow text-entry commands in bindings dialog?

  + windows appear above xscreensaver?

    there's no way around this, xscreensaver maps its virtual root
    window with override_redirect set, so the wm never even sees it
    (otherwise it could be moved to an upper layer)

  + Handle multiple-screen displays

    What are the issues? Multiple root windows, and..?

  + Add checked and radio menu item support

  + Smart placement

    How can the best-fit cost function be improved?

    Maybe define a placement-weight-alist mapping window names to
    overlap weights? Negative weights could be used for windows that we
    don't really mind being covered

  + Handle window groups

    groups as defined by the apps themselves? or user-defined groups?
    or both?

  + better transient handling

    When moving a window to another workspace, also move any transients (?)

  + Pixmap cursors / cursor recolouring

  + Icons (?)

  + Load tarred/compressed themes

  + GUI configuration

    Customization of key bindings is a bit simplistic -- whenever a
    single binding is changed, the whole keymap is then fixed in the
    user's .sawmill-custom file

  + Support the KDE hints

    Where are they defined?

  + clone some ctwm functions:

       f.fill string
               Where string is either : "right", "left", "top" or
               "bottom".  The current window is  resized  in  the
               specified  direction  until it reaches an obstacle
               (either another window, or the screen border).

       f.pack string
               Where string is either : "right", "left", "top" or
               "bottom" The current window is moved in the speci
               fied  direction  until  it  reaches  an   obstacle
               (either another window, or the screen border). The
               pointer follows the window.

       f.bottomzoom
               This function is similar to the  f.fullzoom  func
               tion, but resizes the window to fill only the bot
               tom half of the screen.

       f.leftzoom
               This variable is similar to the f.bottomzoom func
               tion  but  causes  the  selected  window  is  only
               resized to the left half of the display.

       etc.

  - Rotated text

    Allow text to be rendered at angles (in multiples of 90 degrees?).
    This could be useful for the sides of windows

  - GTK theme

    Is there any way that the gtk theme could support engine-based GTK
    themes? Probably not without using a subprocess (since the engines
    are written to GDK, not Xlib), this could get hairy..

    Also, why do themes with bg_pixmap set use so much memory? Is it
    just because the images are XPM's..?

  - Internationalisation

    This should be quite easy, since most strings are stored in the
    documentation databases anyway. So we just need to provide multiple
    DOC files, and some tool to aid in the translation/construction
    process (something like PACE's HMCL parser?) We could probably make
    this tool compatible with the usual .po files

    There are still some strings that aren't already handled as doc
    strings (i.e. menu labels, errors, a few things in sawmill-ui).
    These can also be stored in the DOC file. All keys in the DOC file
    currently start with either `S' (subr) or `V' (variable). So just
    add a new prefix `T' for text string, then use the original string
    as the rest of the key

    This needs to be in rep really. Add a (gettext ID STRING) macro
    that interprets to STRING. The compiler adds STRING to the doc file
    under key ID, inserts code to fetch it back [how can we lose the
    annoying ID parameter?]

    Another option is to have `(defstring VAR STRING)' which resolves
    all strings when the module is loaded, but then you have to declare
    all strings up-front, which would be _really_ annoying

    Also, what about the "%1$s" style printf formatting. rep's format
    function should be extended to handle this syntax


Long term ideas
===============

  - Remove root menu?

    The argument is that doing this removes the need for the wm to
    select ButtonPress events on the root window (which is a point of
    conflict with, for example, a desktop file manager)

    The sole need for the wm to manage the root menus (as far as I can
    see) is so that it can offer window management functions (such as
    "interactively move the focused window" or whatever), but all
    these things can be invoked through sawmill-client, i.e.
    "sawmill-client -c move-window-interactively"

    With a bit of work the dynamically generated menus (e.g. the window
    and workspace submenus) could also be generated through the client

  - Target guile instead of rep

    In theory this is a good idea, probably a lot of work, but still.
    These are some of the arguments/justifications for sticking with
    rep:

	1. The single-threadedness is not a problem for a window
	   manager, where the flow of control pretty much follows the X
	   event queue

	2. It's lighter-weight than guile (though the effects of sharing
	   libraries probably negates this a bit)

	3. I have some half-cooked ideas about using the built-in
	   remote-file handling to access a theme repository somewhere

	4. It has lots of support (i.e. hooks, input handling) for
	   being used as an extension language

    And these are some reasons for using guile:

	1. Scheme's a cleaner and more modern language than rep's Lisp
	   dialect (one namespace, lexical scope, continuations, ...)

	2. More people know scheme than lisp (though the closeness to
	   Emacs-lisp offsets this)

	3. Sawmill would depend on fewer "weird" libraries (librep,
	   rep-gtk), that someone (i.e. me) has to maintain

    The main things counting against guile are that I've never used it,
    and that I'm lazy

  - CORBA interface

    First write CORBA support for rep (does guile support CORBA?), then
    what? Would this be useful?

  - Theme repository

    Something similar to foo.themes.org, but I want to be able to load
    themes straight from the net

    They could be loaded through the remote-ftp system (would need to
    redefine pwd-prompt somehow, GTK?), then installed in the user's
    local theme directory, then activated (all without restarting the
    wm)

    How about a drag 'n drop target in the configurator. Load the
    specified URI then install the theme it contains

    This way you should be able to drag from both netscape and the file
    manager to activate a theme

  - Theme builder

    Use the client to frame a temporary window with control over its
    decorations (GTK interface), then output the Lisp code to build the
    theme
