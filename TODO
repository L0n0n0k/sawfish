-*- indented-text -*-

TODO list for sawmill
*********************

Bugs are marked !, things that should be done soon are marked +,
and longer-term ideas are marked -


Outstanding bugs
================

  ! Without GMC you can press button1 on root window, and holding it
    move over frame, and that frame gets clicked and action bound to
    this frame is taken

    Move cursor very slowly over frame holding button1

  ! While moving or resizing, when you release button and move mouse
    out of frame very fast, frame remains in highlighted state

  ! latency when starting menu subprocesses can be annoying (pointer
    events are handled unintuitively)

  ! shaped frame parts overlapping shaped client windows lose

    does this need fixing..? similarly, shaped frame parts overlapping
    each other will overwrite the lower part's mask..

  ! It's not possible to compile sawmill-ui.jl without an X connection
    (it requires 'gtk, which then calls gtk_init (), ...)

  ! Move functions.c:Fgetpid () to librep

  ! install-sh script isn't found from subdirectories?

    [workaround: install GNU fileutils]

  ! the configuration tool doesn't use gtk engine themes correctly (cf.
    the scrollbars)

    [ 22/9: this happens because the engine doesn't have a library
      dependency on libglib.so. I could add RTLD_GLOBAL to
      rep_open_dl_library () but this isn't a good idea since it would
      expose the internals of all plugins to everything else..

      -- gtk-engines on cvs.gnome.org has this fixed ]

  ! ICCCM says we should not passive grab on the client windows, but on
    our frames instead


General tasks
=============

  + create a "never automatically create new workspaces" option?

  + add capplet desktop entries to share/gnome/apps/Settings as well as
    the control center tree

    then again.. there's a problem with this -- gnome menus are
    _static_, whereas sawmill's customization groups are _dynamic_

    i.e. the `customization' root sub-menu wouldn't match the menu in
    the gnome `settings' tree. this would be bad since the user may not
    discover the dynamic menu and thus miss many of the options..

  + code to read the gnome apps menu, then replace apps-menu

  + Ability to execute commands (like select-workspace:X) while
    moving/resizing.

    Could solve this by specifying a keymap to the
    grab-pointer/grab-keyboard functions, then evaluate the other type
    of events as normal

    Would this introduce other problems..? What if the outer command
    has the server grabbed (e.g. rubber-banding in progress)

    Also, what protection is there against the user doing something
    "foolish"? (like switching desktops while resizing a window)

  + option to maximize with frame outside the root boundaries?

    but only put the border of the window outside, not the title

    this would be hard to achieve (i.e. parsing the frame def)

  + option to disable moving/resizing in maximized state

    Why? I think that the user should always be able to manipulate the
    window if they wish to do so

  + tooltips in frame parts describing their keymaps

    requires extending show-message to do multi-line (justification?)

  + in interactive placement, allow the window-pointer position to be
    configurable 

  + change edge snapping to use resistance instead of magnetism?

  + allow configuration of where move/resize display appears

    allow relative to window, or relative to root, for both x and y

  + option for maximizing not to cover panels

  + viewport-based workspaces

    possibly just do workspaces as an N-d structure, then expand to a
    regular cube for the pager..?

    --I've tried this (and have the diffs to prove it), but even though
    it works ok (encoding N-d indices in the workspace number), the
    user interface is horrible

    this is why I like the expanding 1d structure--its so simple

  + Allow text-entry commands in bindings dialog?

  + windows appear above xscreensaver?

    there's no way around this, xscreensaver maps its virtual root
    window with override_redirect set, so the wm never even sees it
    (otherwise it could be moved to an upper layer)

  + Handle multiple-screen displays

    What are the issues? Multiple root windows, and..?

  + Add checked and radio menu item support

  + Smart placement

    How can the best-fit cost function be improved?

    Maybe define a placement-weight-alist mapping window names to
    overlap weights? Negative weights could be used for windows that we
    don't really mind being covered

  + Handle window groups

    groups as defined by the apps themselves? or user-defined groups?
    or both?

  + better transient handling

    When moving a window to another workspace, also move any transients (?)

  + Pixmap cursors / cursor recolouring

  + Icons (?)

  + Load tarred/compressed themes

  + GUI configuration

    Customization of key bindings is a bit simplistic -- whenever a
    single binding is changed, the whole keymap is then fixed in the
    user's .sawmill-custom file

  + Support the KDE hints

    Where are they defined?

  - Rotated text

    Allow text to be rendered at angles (in multiples of 90 degrees?).
    This could be useful for the sides of windows

  - GTK theme

    Is there any way that the gtk theme could support engine-based GTK
    themes? Probably not without using a subprocess (since the engines
    are written to GDK, not Xlib), this could get hairy..

    Also, why do themes with bg_pixmap set use so much memory? Is it
    just because the images are XPM's..?

  - Internationalisation

    This should be quite easy, since most strings are stored in the
    documentation databases anyway. So we just need to provide multiple
    DOC files, and some tool to aid in the translation/construction
    process (something like PACE's HMCL parser?) We could probably make
    this tool compatible with the usual .po files

    There are still some strings that aren't already handled as doc
    strings (i.e. menu labels, errors, a few things in sawmill-ui).
    These can also be stored in the DOC file. All keys in the DOC file
    currently start with either `S' (subr) or `V' (variable). So just
    add a new prefix `T' for text string, then use the original string
    as the rest of the key

    This needs to be in rep really. Add a (gettext ID STRING) macro
    that interprets to STRING. The compiler adds STRING to the doc file
    under key ID, inserts code to fetch it back [how can we lose the
    annoying ID parameter?]

    Another option is to have `(defstring VAR STRING)' which resolves
    all strings when the module is loaded, but then you have to declare
    all strings up-front, which would be _really_ annoying

    Also, what about the "%1$s" style printf formatting. rep's format
    function should be extended to handle this syntax


Long term ideas
===============

  - Remove root menu?

    The argument is that doing this removes the need for the wm to
    select ButtonPress events on the root window (which is a point of
    conflict with, for example, a desktop file manager)

    The sole need for the wm to manage the root menus (as far as I can
    see) is so that it can offer window management functions (such as
    "interactively move the focused window" or whatever), but all
    these things can be invoked through sawmill-client, i.e.
    "sawmill-client -c move-window-interactively"

    With a bit of work the dynamically generated menus (e.g. the window
    and workspace submenus) could also be generated through the client

  - Target guile instead of rep

    In theory this is a good idea, probably a lot of work, but still.
    These are some of the arguments/justifications for sticking with
    rep:

	1. The single-threadedness is not a problem for a window
	   manager, where the flow of control pretty much follows the X
	   event queue

	2. It's lighter-weight than guile (though the effects of sharing
	   libraries probably negates this a bit)

	3. I have some half-cooked ideas about using the built-in
	   remote-file handling to access a theme repository somewhere

	4. It has lots of support (i.e. hooks, input handling) for
	   being used as an extension language

    And these are some reasons for using guile:

	1. Scheme's a cleaner and more modern language than rep's Lisp
	   dialect (one namespace, lexical scope, continuations, ...)

	2. More people know scheme than lisp (though the closeness to
	   Emacs-lisp offsets this)

	3. Sawmill would depend on fewer "weird" libraries (librep,
	   rep-gtk), that someone (i.e. me) has to maintain

    The main things counting against guile are that I've never used it,
    and that I'm lazy

  - CORBA interface

    First write CORBA support for rep (does guile support CORBA?), then
    what? Would this be useful?

  - Theme repository

    Something similar to foo.themes.org, but I want to be able to load
    themes straight from the net

    They could be loaded through the remote-ftp system (would need to
    redefine pwd-prompt somehow, GTK?), then installed in the user's
    local theme directory, then activated (all without restarting the
    wm)

    How about a drag 'n drop target in the configurator. Load the
    specified URI then install the theme it contains

    This way you should be able to drag from both netscape and the file
    manager to activate a theme

  - Theme builder

    Use the client to frame a temporary window with control over its
    decorations (GTK interface), then output the Lisp code to build the
    theme
